---
layout: post
title: Exploiting Integer overflows
date: 2022-12-23 10:57:00
description: Exploiting Integer overflows
categories: Security
tags: exploiting C/C++ linux macos windows
---

This entry consists of the exploitation of the "Integer Overflow" vulnerability. Although it can be performed on any type of operating system I will use a Ubuntu linux ARM 32 bits system (On a raspberry pi!).

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/blog/2022-12-23-exploiting-integer-overflows/001-uname.png" class="img-fluid rounded" zoomable=true %}
    </div>
</div>

<br/>
## Understanding the concept

Among the vulnerabilities present in low-level programs, integer overflows are the easiest to find, and their concept is also quite simple. The integer overflows themselves do not provide us with the ability to perform code injection or reverse shell. They are something much simpler, however they allow us to reach sections of the code that could be vulnerable, evading validations or simply causing undefined behaviors in the application. The concept of this vulnerability will be explained below with examples from a 32-bit system.

An integer is a variable that is stored in memory. This variable takes up 32 bits in the case of an x32 architecture. In addition, integers can be signed, so depending on whether they are signed or unsigned, a bit is used to mark whether this number is positive or negative. Taking this into account, an unsigned integer can be in the range of 0 to 4294967296 (2^32). In the case of signed integers, the absolute value decreases by half (by losing 1 bit for the sign) but we can represent negative numbers. A signed integer is in the range of values from -2147483648 to +2147483648 (2^31). It is important to keep in mind that the bit indicating the sign is always placed in the most significant bit (MSB).

The attack we will carry out consists of asking ourselves: What would happen if we cast an unsigned integer to a signed integer? Looking at the values above we can see how the same binary code representation of a number produces different values depending on the type of the variable.

<br/>
## Basic proof of concept

To make a proof of concept we will use the following code in C. This code receives a number as input parameter. This number refers to resources such as keys or numbers stored in the software. As we can see, inside the main function, those ids greater than 100 are reserved for administrators. In case of a standard user resource, a number will be returned. In case of being an administrator resource, the password to enter another system will be returned. As we can see, the main method will validate that no numbers greater than 100 are entered.

Vulnerable source code:

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void runResource(unsigned int id) {
	printf("runResource: %u\n", id);
	if(id > 100) {
		printf("Hi admministrator! ");
		printf("Here you have your forgotten password: patata1234.\n");
		return;
	}
	printf("Here you have your resource:\n");
	printf("%d\n", id + 39);
	printf("Yes, your resource is just a number.\n");
}

int main(int argc, char* argv[]) {
	int resourceId;
	sscanf(argv[1], "%d", &resourceId);
	printf("Main: %d\n", resourceId);
	if(resourceId > 100) {
		printf("Unauthorized. ");
		printf("Only administrators can access >100 resources.\n");
		return 1;
	}
	runResource(resourceId);
	return 0;
}
```

Lets compile the source code with the following command:

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/blog/2022-12-23-exploiting-integer-overflows/002-compile.png" class="img-fluid rounded" zoomable=true %}
    </div>
</div>

Lets see the basic usage of this program. We will see how entering a number less than 100 returns another number. If we enter a number greater than 100, we will receive an error.

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/blog/2022-12-23-exploiting-integer-overflows/003-normal-usage.png" class="img-fluid rounded" zoomable=true %}
    </div>
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/blog/2022-12-23-exploiting-integer-overflows/004-unauthorized.png" class="img-fluid rounded" zoomable=true %}
    </div>
</div>

And now lets see what happen if we insert a negative number.

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/blog/2022-12-23-exploiting-integer-overflows/005-malicious-usage.png" class="img-fluid rounded" zoomable=true %}
    </div>
</div>

In this case we have obtained the password. As can be seen in the program logs, in the main method the value entered was a negative number. However, when converting this number to an unsigned number, the most significant bit that was indicating the sign becomes part of the value of the number. Greatly increasing it.

<br/>
## Using Integer overflow to reach BufferOverflow

The previous case was very good for understanding the concept, but it is not very good for understanding to how for example we can use it to take control of the system. In the case of the following example, we will use the same structure to generate a buffer with a specific amount of ones. In this program 2 parameters will be indicated as input. The first one is the size of the buffer we want to create. The second parameter is the number of ones we want it to have. If the number of ones exceeds the size of the buffer, the program will terminate.

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int* buildBuffer(unsigned int bufferSize, unsigned int onesToWrite) {
	int buffer[bufferSize];
	unsigned int i;
	printf("buildBuffer -> Creating a %u size buffer with: %u ones.\n", bufferSize, onesToWrite);
	for(i = 0; i < onesToWrite; i++) {
		buffer[i] = 1;
		printf(". ");
	}
	return buffer;
}

int main(int argc, char* argv[]) {
	int bufferLen;
	int onesToWrite;

	sscanf(argv[1], "%d", &bufferLen);
	sscanf(argv[2], "%d", &onesToWrite);

	if(onesToWrite > bufferLen) {
		printf("Nice try.");
		return 1;
	}

	printf("main -> Software will fill a %d size buffer with: %d ones.\n", bufferLen, onesToWrite);
	buildBuffer(bufferLen, onesToWrite);

	return 0;
}
```

As we can see in the following images, this the normal usage.

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/blog/2022-12-23-exploiting-integer-overflows/006-normal-usage.png" class="img-fluid rounded" zoomable=true %}
    </div>
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/blog/2022-12-23-exploiting-integer-overflows/007-normal-usage.png" class="img-fluid rounded" zoomable=true %}
    </div>
</div>

However, using the same technique as in the first software, we can enter a "-1" which will result in a gigantic value compared to the size of the defined buffer.

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/blog/2022-12-23-exploiting-integer-overflows/008-buffer-overflow.png" class="img-fluid rounded" zoomable=true %}
    </div>
</div>

We have finally succeeded in generating a bufferoverflow. As we said, although the vulnerability itself does not allow us to take control of the system, it does allow us to evade some security validations and even allows us to reach even more serious vulnerabilities as in this case a buffer overflow.
