---
title: Exploiting Integer overflows
pubDate: "Dec 23 2022"
description: Exploiting Integer overflows
tags: ["security", "c/c++", "linux", "hacking", "vulnerabilities"]
heroImage: "/blog/2022-12-23-exploiting-integer-overflows/logo.png"
---

This entry consists of the exploitation of the "Integer Overflow" vulnerability. Although it can be performed on any type of operating system I will use a Ubuntu linux ARM 32 bits system (On a raspberry pi!).

## Understanding the concept

Among the vulnerabilities present in low-level programs, integer overflows are the easiest to find, and their concept is also quite simple. The integer overflows themselves do not provide us with the ability to perform code injection or establish a reverse shell. They are something much simpler, however they allow us to reach sections of the code that could be vulnerable, evading validations or result in abnormal behaviors.

First of all, let's talk about integers and how they are stored in memory. An integer is a variable that is stored in memory. This variable takes up 32 bits in the case of an x32 architecture. In addition, integers can be signed, so depending on whether they are signed or unsigned, a bit is used to mark whether this number is positive or negative. Taking this into account, an unsigned integer can be in the range of 0 to 4294967296 (2^32). 
In the case of signed integers, the absolute value decreases by half (by losing 1 bit for the sign) but we can represent negative numbers. A signed integer is in the range of values from -2147483648 to +2147483648 (2^31). It is important to keep in mind that the bit indicating the sign is always placed in the most significant bit (MSB).

## Basic proof of concept

The attack we will carry out consists of asking ourselves: What would happen if we cast an unsigned integer to a signed integer? Looking at the ranges above we can see how the same binary code representation of a number produces different values depending on the type of the variable. 

In the case of the following example, program takes 2 arguments. The first one is the size of the buffer we want to create. The second parameter is the number of ones we want it to have. If the number of ones exceeds the size of the buffer, the program will terminate.

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int* buildBuffer(unsigned int bufferSize, unsigned int onesToWrite) {
	int buffer[bufferSize];
	unsigned int i;
	printf("buildBuffer -> Creating a %u size buffer with: %u ones.\n", bufferSize, onesToWrite);
	for(i = 0; i < onesToWrite; i++) {
		buffer[i] = 1;
		printf(". ");
	}
	return buffer;
}

int main(int argc, char* argv[]) {
	int bufferLen;
	int onesToWrite;

	sscanf(argv[1], "%d", &bufferLen);
	sscanf(argv[2], "%d", &onesToWrite);

	if(onesToWrite > bufferLen) {
		printf("Nice try.");
		return 1;
	}

	printf("main -> Software will fill a %d size buffer with: %d ones.\n", bufferLen, onesToWrite);
	buildBuffer(bufferLen, onesToWrite);

	return 0;
}
```

As we can see in the following images, this the normal usage.

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
		<img src="/blog/2022-12-23-exploiting-integer-overflows/006-normal-usage.png"></img>
    </div>
    <div class="col-sm mt-3 mt-md-0">
		<img src="/blog/2022-12-23-exploiting-integer-overflows/007-normal-usage.png"></img>
    </div>
</div>

We can enter a "-1" which will result in a gigantic value compared to the size of the defined buffer. This is because the type transformation has been performed, but the bits in the register remain exactly the same. The difference is that now we interpret that bit (which used to represent the sign) as part of the number. However, the validation that the number is smaller than the buffer size, is done before the data type transformation (which is automatically performed when calling the function).

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
		<img src="/blog/2022-12-23-exploiting-integer-overflows/008-buffer-overflow.png"></img>
    </div>
</div>

We have finally succeeded in generating a bufferoverflow. As we said, although the vulnerability itself does not allow us to take control of the system, it does allow us to evade some security validations and even allows us to reach even more serious vulnerabilities as in this case a buffer overflow.
